glActiveShaderProgram
void glActiveShaderProgram(GLuint pipeline, GLuint program);
GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 
GL_INVALID_OPERATION is generated if program refers to a program object that has not been successfully linked. 

glActiveTexture
void glActiveTexture(GLenum texture);
GL_INVALID_ENUM is generated if texture is not one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). 

glAttachShader
void glAttachShader(GLuint program, GLuint shader);
GL_INVALID_VALUE is generated if eitherprogram or shaderis not a value generated by OpenGL.
GL_INVALID_OPERATION is generated ifprogram is not a program object.
GL_INVALID_OPERATION is generated ifshader is not a shader object.
GL_INVALID_OPERATION is generated ifshader is already attached toprogram.

glBeginConditionalRender
void glBeginConditionalRender(GLuint id, GLenum mode);
GL_INVALID_VALUE is generated if id is not the name of an existing query object. 
GL_INVALID_ENUM is generated if mode is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if glBeginConditionalRender is called while conditional rendering is active, or if glEndConditionalRender is called while conditional rendering is inactive. 
GL_INVALID_OPERATION is generated if id is the name of a query object with a target other than GL_SAMPLES_PASSED or GL_ANY_SAMPLES_PASSED. 
GL_INVALID_OPERATION is generated if id is the name of a query currently in progress. 

glEndConditionalRender
void glEndConditionalRender(void);
GL_INVALID_VALUE is generated if id is not the name of an existing query object. 
GL_INVALID_ENUM is generated if mode is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if glBeginConditionalRender is called while conditional rendering is active, or if glEndConditionalRender is called while conditional rendering is inactive. 
GL_INVALID_OPERATION is generated if id is the name of a query object with a target other than GL_SAMPLES_PASSED or GL_ANY_SAMPLES_PASSED. 
GL_INVALID_OPERATION is generated if id is the name of a query currently in progress. 

glBeginQuery
void glBeginQuery(GLenum target, GLuint id);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if glBeginQuery is executed while a query object of the same target is already active. 
GL_INVALID_OPERATION is generated if glEndQuery is executed when a query object of the same target is not active. 
GL_INVALID_OPERATION is generated if id is 0. 
GL_INVALID_OPERATION is generated if id is the name of an already active query object. 
GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target. 

glEndQuery
void glEndQuery(GLenum target);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if glBeginQuery is executed while a query object of the same target is already active. 
GL_INVALID_OPERATION is generated if glEndQuery is executed when a query object of the same target is not active. 
GL_INVALID_OPERATION is generated if id is 0. 
GL_INVALID_OPERATION is generated if id is the name of an already active query object. 
GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target. 

glBeginQueryIndexed
void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_VALUE is generated if index is greater than the query target-specific maximum. 
GL_INVALID_OPERATION is generated if glBeginQueryIndexed is executed while a query object of the same target is already active. 
GL_INVALID_OPERATION is generated if glEndQueryIndexed is executed when a query object of the same target is not active. 
GL_INVALID_OPERATION is generated if id is 0. 
GL_INVALID_OPERATION is generated if id is the name of an already active query object. 
GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target. 

glEndQueryIndexed
void glEndQueryIndexed(GLenum target, GLuint index);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_VALUE is generated if index is greater than the query target-specific maximum. 
GL_INVALID_OPERATION is generated if glBeginQueryIndexed is executed while a query object of the same target is already active. 
GL_INVALID_OPERATION is generated if glEndQueryIndexed is executed when a query object of the same target is not active. 
GL_INVALID_OPERATION is generated if id is 0. 
GL_INVALID_OPERATION is generated if id is the name of an already active query object. 
GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target. 

glBeginTransformFeedback
void glBeginTransformFeedback(GLenum primitiveMode);
GL_INVALID_OPERATION is generated if glBeginTransformFeedback is executed while transform feedback is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback is executed while transform feedback is not active. 
GL_INVALID_OPERATION is generated by glDrawArrays if no geometry shader is present, transform feedback is active and mode is not one of the allowed modes. 
GL_INVALID_OPERATION is generated by glDrawArrays if a geometry shader is present, transform feedback is active and the output primitive type of the geometry shader does not match the transform feedback primitiveMode. 
GL_INVALID_OPERATION is generated by glEndTransformFeedback if any binding point used in transform feedback mode does not have a buffer object bound. 
GL_INVALID_OPERATION is generated by glEndTransformFeedback if no binding points would be used, either because no program object is active of because the active program object has specified no varying variables to record. 

glEndTransformFeedback
void glEndTransformFeedback(void);
GL_INVALID_OPERATION is generated if glBeginTransformFeedback is executed while transform feedback is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback is executed while transform feedback is not active. 
GL_INVALID_OPERATION is generated by glDrawArrays if no geometry shader is present, transform feedback is active and mode is not one of the allowed modes. 
GL_INVALID_OPERATION is generated by glDrawArrays if a geometry shader is present, transform feedback is active and the output primitive type of the geometry shader does not match the transform feedback primitiveMode. 
GL_INVALID_OPERATION is generated by glEndTransformFeedback if any binding point used in transform feedback mode does not have a buffer object bound. 
GL_INVALID_OPERATION is generated by glEndTransformFeedback if no binding points would be used, either because no program object is active of because the active program object has specified no varying variables to record. 

glBindAttribLocation
void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_OPERATION is generated if name starts with the reserved prefix "gl_".
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.

glBindBuffer
void glBindBuffer(GLenum target, GLuint buffer);
GL_INVALID_ENUM is generated if target is not one of the allowable values. 
GL_INVALID_VALUE is generated if buffer is not a name previously returned from a call to glGenBuffers. 

glBindBufferBase
void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. 
GL_INVALID_VALUE is generated if index is greater than or equal to the number of target-specific indexed binding points. 
GL_INVALID_VALUE is generated if buffer does not have an associated data store, or if the size of that store is zero. 

glBindBufferRange
void glBindBufferRange(GLenumtarget, GLuintindex, GLuintbuffer, GLintptroffset, GLsizeiptrsize);
GL_INVALID_ENUM is generated if target is not one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. 
GL_INVALID_VALUE is generated if index is greater than or equal to the number of target-specific indexed binding points. 
GL_INVALID_VALUE is generated if size is less than or equal to zero, or if offset + size is greater than the value of GL_BUFFER_SIZE. 
Additional errors may be generated if offset violates any target-specific alignmemt restrictions. 

glBindBufferBase
void glBindBufferBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers);
GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. 
GL_INVALID_OPERATION is generated if first + count is greater than the number of target-specific indexed binding points. 
GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object. 

glBindBuffersRange
void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLintptr *sizes);
GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. 
GL_INVALID_OPERATION is generated if first + count is greater than the number of target-specific indexed binding points. 
GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object. 
GL_INVALID_VALUE is generated by if any value in offsets is less than zero or if any value in sizes is less than zero. 
GL_INVALID_VALUE is generated if any pair of values in offsets and sizes does not respectively satisfy the constraints described for those parameters for the specified target. 

glBindFragDataLocation
void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char * name);
GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_OPERATION is generated if name starts with the reserved gl_ prefix. 
GL_INVALID_OPERATION is generated if program is not the name of a program object. 

glBindFragDataLocationIndexed
void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char *name);
GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DUAL_SOURCE_DRAW_BUFFERS and index is greater than or equal to one. 
GL_INVALID_VALUE is generated if index is greater than one. 
GL_INVALID_OPERATION is generated if name starts with the reserved gl_ prefix. 
GL_INVALID_OPERATION is generated if program is not the name of a program object. 

glBindFramebuffer
void glBindFramebuffer(GLenum target, GLuint framebuffer);
GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. 
GL_INVALID_OPERATION is generated if framebuffer is not zero or the name of a framebuffer previously returned from a call to glGenFramebuffers. 

glBindImageTexture
void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
GL_INVALID_VALUE is generated if unit greater than or equal to the value of GL_MAX_IMAGE_UNITS. 
GL_INVALID_VALUE is generated if texture is not the name of an existing texture object. 
GL_INVALID_VALUE is generated if level or layer is less than zero. 
GL_INVALID_ENUM is generated if access or format is not one of the supported tokens. 

glBindImageTextures
void glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures);
GL_INVALID_OPERATION is generated if first + count is greater than the number of image units supported by the implementation. 
GL_INVALID_OPERATION is generated if any value in textures is not zero or the name of an existing texture object. 
GL_INVALID_OPERATION error is generated if the internal format of the level zero texture image of any texture in textures is not supported. 
GL_INVALID_OPERATION error is generated if the width, height, or depth of the level zero texture image of any texture in textures is zero. 

glBindProgramPipeline
void glBindProgramPipeline(GLuint pipeline);
GL_INVALID_OPERATION is generated if pipeline is not zero or a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 

glBindRenderbuffer
void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if renderbuffer is not zero or the name of a renderbuffer previously returned from a call to glGenRenderbuffers. 

glBindSampler
void glBindSampler(GLuint unit, GLuint sampler);
GL_INVALID_VALUE is generated if unit is greater than or equal to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS. 
GL_INVALID_OPERATION is generated if sampler is not zero or a name previously returned from a call to glGenSamplers, or if such a name has been deleted by a call to glDeleteSamplers. 

glBindSamplers
void glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers);
GL_INVALID_OPERATION is generated if first + count is greater than the number of sampler units supported by the implementation. 
GL_INVALID_OPERATION is generated if any value in samplers is not zero or the name of an existing sampler object. 

glBindTexture
void glBindTexture(GLenum target, GLuint texture);
GL_INVALID_ENUM is generated if target is not one of the allowable values. 
GL_INVALID_VALUE is generated if target is not a name returned from a previous call to glGenTextures. 
GL_INVALID_OPERATION is generated if texture was previously created with a target that doesn't match that of target. 

glBindTextures
void glBindTextures(GLuint first, GLsizei count, const GLuint *textures);
GL_INVALID_OPERATION is generated if first + count is greater than the number of texture image units supported by the implementation. 
GL_INVALID_OPERATION is generated if any value in textures is not zero or the name of an existing texture object. 

glBindTransformFeedback
void glBindTransformFeedback(GLenum target, GLuint id);
GL_INVALID_ENUM is generated if target is not GL_TRANSFORM_FEEDBACK. 
GL_INVALID_OPERATION is generated if the transform feedback operation is active on the currently bound transform feedback object, and that operation is not paused. 
GL_INVALID_OPERATION is generated if id is not zero or the name of a transform feedback object returned from a previous call to glGenTransformFeedbacks, or if such a name has been deleted by glDeleteTransformFeedbacks. 

glBindVertexArray
void glBindVertexArray(GLuint array);
GL_INVALID_OPERATION is generated if array is not zero or the name of a vertex array object previously returned from a call to glGenVertexArrays. 

glBindVertexBuffer
void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride);
GL_INVAILD_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_VALUE is generated if offset or stride is less than zero. 
GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

glBindVertexBuffers
void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLuintptr *offsets, const GLsizei *strides);
GL_INVALID_OPERATION is generated if first + count is greater than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object. 
GL_INVALID_VALUE is generated if any value in offsets or strides is negative, or if a value is stride is greater than the value of GL_MAX_VERTEX_ATTRIB_STRIDE. 

glBlendColor
void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);

glBlendEquation
void glBlendEquation(GLenum mode);
GL_INVALID_ENUM is generated if mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN. 
GL_INVALID_VALUE is generated by glBlendEquationi if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

glBlendEquationi
void glBlendEquationi(GLuint buf, GLenum mode);
GL_INVALID_ENUM is generated if mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN. 
GL_INVALID_VALUE is generated by glBlendEquationi if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

glBlendEquationSeparate
void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
GL_INVALID_ENUM is generated if either modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN. 
GL_INVALID_VALUE is generated by glBlendEquationSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

glBlendEquationSeparatei
void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
GL_INVALID_ENUM is generated if either modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN. 
GL_INVALID_VALUE is generated by glBlendEquationSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

glBlendFunc
void glBlendFunc(GLenum sfactor, GLenum dfactor);
GL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value. 
GL_INVALID_VALUE is generated by glBlendFunci if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

glBlendFunci
void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor);
GL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value. 
GL_INVALID_VALUE is generated by glBlendFunci if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

glBlendFuncSeparate
void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
GL_INVALID_ENUM is generated if either srcRGB or dstRGB is not an accepted value. 
GL_INVALID_VALUE is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

glBlendFuncSeparatei
void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
GL_INVALID_ENUM is generated if either srcRGB or dstRGB is not an accepted value. 
GL_INVALID_VALUE is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

glBlitFramebuffer
void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
GL_INVALID_OPERATION is generated if mask contains any of the GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and filter is not GL_NEAREST. 
GL_INVALID_OPERATION is generated if mask contains GL_COLOR_BUFFER_BIT and any of the following conditions hold: 
The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point values.
The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values.
The read buffer contains signed integer values and any draw buffer does not contain signed integer values.

GL_INVALID_OPERATION is generated if mask contains GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and the source and destination depth and stencil formats do not match. 
GL_INVALID_OPERATION is generated if filter is GL_LINEAR and the read buffer contains integer data. 
GL_INVALID_OPERATION is generated if the value of GL_SAMPLES for the read and draw buffers is not identical. 
GL_INVALID_OPERATION is generated if GL_SAMPLE_BUFFERS for both read and draw buffers greater than zero and the dimensions of the source and destination rectangles is not identical. 
GL_INVALID_FRAMEBUFFER_OPERATION is generated if the objects bound to GL_DRAW_FRAMEBUFFER_BINDING or GL_READ_FRAMEBUFFER_BINDING are not framebuffer complete. 

glBufferData
void glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);
GL_INVALID_ENUM is generated if target is not one of the accepted buffer targets. 
GL_INVALID_ENUM is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY. 
GL_INVALID_VALUE is generated if size is negative. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the specified size. 

glBufferStorage
void glBufferStorage(GLenum target, GLsizeiptr size, const GLvoid * data, GLbitfield flags);
GL_INVALID_ENUM is generated if target is not one of the accepted buffer targets. 
GL_INVALID_VALUE is generated if size is less than or equal to zero. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the properties requested in flags. 
GL_INVALID_VALUE is generated if flags has any bits set other than those defined above. 
GL_INVALID_VALUE error is generated if flags contains GL_MAP_PERSISTENT_BIT but does not contain at least one of GL_MAP_READ_BIT or GL_MAP_WRITE_BIT. 
GL_INVALID_VALUE is generated if flags contains GL_MAP_COHERENT_BIT, but does not also contain GL_MAP_PERSISTENT_BIT. 
GL_INVALID_OPERATION is generated if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer bound to target is GL_TRUE. 

glBufferSubData
void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not one of the accepted buffer targets. 
GL_INVALID_VALUE is generated if offset or size is negative, or if together they define a region of memory that extends beyond the buffer object's allocated data store. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_INVALID_OPERATION is generated if the buffer object being updated is mapped. 

glCheckFramebufferStatus
GLenum glCheckFramebufferStatus(GLenum target);
GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. 

glClampColor
void glClampColor(GLenum target, GLenum clamp);
GL_INVALID_ENUM is generated if target is not GL_CLAMP_READ_COLOR. 
GL_INVALID_ENUM is generated if clamp is not GL_TRUE or GL_FALSE. 

glClear
void glClear(GLbitfield mask);
GL_INVALID_VALUE is generated if any bit other than the three defined bits is set in mask. 

glClearBufferiv
void glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint * value);
GL_INVALID_ENUM is generated by glClearBufferif, glClearBufferfv and glClearBufferuiv if buffer is not GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_DEPTH or GL_STENCIL. 
GL_INVALID_ENUM is generated by glClearBufferfi if buffer is not GL_DEPTH_STENCIL. 
GL_INVALID_VALUE is generated if buffer is GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, or GL_FRONT_AND_BACK and drawBuffer is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if buffer is GL_DEPTH, GL_STENCIL or GL_DEPTH_STENCIL and drawBuffer is not zero. 

glClearBufferuiv
void glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint * value);
GL_INVALID_ENUM is generated by glClearBufferif, glClearBufferfv and glClearBufferuiv if buffer is not GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_DEPTH or GL_STENCIL. 
GL_INVALID_ENUM is generated by glClearBufferfi if buffer is not GL_DEPTH_STENCIL. 
GL_INVALID_VALUE is generated if buffer is GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, or GL_FRONT_AND_BACK and drawBuffer is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if buffer is GL_DEPTH, GL_STENCIL or GL_DEPTH_STENCIL and drawBuffer is not zero. 

glClearBufferfv
void glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat * value);
GL_INVALID_ENUM is generated by glClearBufferif, glClearBufferfv and glClearBufferuiv if buffer is not GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_DEPTH or GL_STENCIL. 
GL_INVALID_ENUM is generated by glClearBufferfi if buffer is not GL_DEPTH_STENCIL. 
GL_INVALID_VALUE is generated if buffer is GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, or GL_FRONT_AND_BACK and drawBuffer is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if buffer is GL_DEPTH, GL_STENCIL or GL_DEPTH_STENCIL and drawBuffer is not zero. 

glClearBufferfi
void glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
GL_INVALID_ENUM is generated by glClearBufferif, glClearBufferfv and glClearBufferuiv if buffer is not GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_DEPTH or GL_STENCIL. 
GL_INVALID_ENUM is generated by glClearBufferfi if buffer is not GL_DEPTH_STENCIL. 
GL_INVALID_VALUE is generated if buffer is GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, or GL_FRONT_AND_BACK and drawBuffer is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if buffer is GL_DEPTH, GL_STENCIL or GL_DEPTH_STENCIL and drawBuffer is not zero. 

glClearBufferData
void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
GL_INVALID_ENUM is generated if target not one of the generic buffer binding targets. 
GL_INVALID_VALUE is generated if no buffer is bound to target. 
GL_INVALID_ENUM is generated if internalformat is not a sized internal format. 
GL_INVALID_OPERATION is generated if any part of the buffer's data store is mapped with glMapBufferRange or glMapBuffer. 

glClearBufferSubData
void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
GL_INVALID_ENUM is generated if target not one of the generic buffer binding targets. 
GL_INVALID_VALUE is generated if no buffer is bound to target. 
GL_INVALID_ENUM is generated if internalformat is not a sized internal format. 
GL_INVALID_VALUE is generated if offset or range are not multiples of the number of basic machine units per-element for the internal format specified by internalformat. 
GL_INVALID_VALUE is generated if offset or size is less than zero, or if offset + size is greater than the value of GL_BUFFER_SIZE for the buffer bound to target. 
GL_INVALID_OPERATION is generated if any part of the specified buffer range is mapped with glMapBufferRange or glMapBuffer. 

glClearColor
void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);

glClearDepth
void glClearDepth(GLdouble depth);

glClearDepthf
void glClearDepthf(GLfloat depth);

glClearStencil
void glClearStencil(GLint s);

glClearTexImage
void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);
GL_INVALID_OPERATION is generated if texture is zero or not the name of an existing texture object. 
GL_INVALID_OPERATION is generated if texture is a buffer texture. 
GL_INVALID_OPERATION is generated if texture has a compressed internal format. 
GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_COMPONENT and format is not GL_DEPTH_COMPONENT. 
GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_STENCIL and format is not GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if the base internal format is GL_STENCIL_INDEX and format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if the base internal format is GL_RGBA and format is GL_DEPTH_COMPONENT, GL_STENCIL_INDEX, or GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if the internal format is integer and format does not specify integer data. 
GL_INVALID_OPERATION is generated if the internal format is not integer and format specifies integer data. 
GL_INVALID_OPERATION is generated if the image array identified by level has not previously been defined by a call to glTexImage* or glTexStorage*. 

glClearTexSubImage
void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);
GL_INVALID_OPERATION is generated if texture is zero or not the name of an existing texture object. 
GL_INVALID_OPERATION is generated if texture is a buffer texture. 
GL_INVALID_OPERATION is generated if texture has a compressed internal format. 
GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_COMPONENT and format is not GL_DEPTH_COMPONENT. 
GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_STENCIL and format is not GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if the base internal format is GL_STENCIL_INDEX and format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if the base internal format is GL_RGBA and format is GL_DEPTH_COMPONENT, GL_STENCIL_INDEX, or GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if the internal format is integer and format does not specify integer data. 
GL_INVALID_OPERATION is generated if the internal format is not integer and format specifies integer data. 
GL_INVALID_OPERATION error is generated if the xoffset, yoffset, zoffset, width, height, and depth parameters (or combinations thereof) specify a region that falls outside the defined texture image array (including border, if any). 

glClientWaitSync
GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
GL_INVALID_VALUE is generated if sync is not the name of an existing sync object. 
GL_INVALID_VALUE is generated if flags contains any unsupported flag. 

glColorMask
void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);

glColorMaski
void glColorMaski(GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);

glCompileShader
void glCompileShader(GLuint shader);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if shader is not a shader object.

glCompressedTexImage1D
void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is not a supported specific compressed internal formats, or is one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

glCompressedTexImage2D
void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is not one of the specific compressed internal formats: GL_COMPRESSED_RED_RGTC1, GL_COMPRESSED_SIGNED_RED_RGTC1, GL_COMPRESSED_RG_RGTC2, GL_COMPRESSED_SIGNED_RG_RGTC2. GL_COMPRESSED_RGBA_BPTC_UNORM, GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, GL_COMPRESSED_RGB8_ETC2, GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC, GL_COMPRESSED_RG11_EAC, or GL_COMPRESSED_SIGNED_RG11_EAC. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

glCompressedTexImage3D
void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

glCompressedTexSubImage1D
void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

glCompressedTexSubImage2D
void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

glCompressedTexSubImage3D
void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

glCopyBufferSubData
void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
GL_INVALID_VALUE is generated if any of readoffset, writeoffset or size is negative, if readoffset + size exceeds the size of the buffer object bound to readtarget or if writeoffset + size exceeds the size of the buffer object bound to writetarget. 
GL_INVALID_VALUE is generated if the same buffer object is bound to both readtarget and writetarget and the ranges [readoffset, readoffset + size) and [writeoffset, writeoffset + size) overlap. 
GL_INVALID_OPERATION is generated if zero is bound to readtarget or writetarget. 
GL_INVALID_OPERATION is generated if the buffer object bound to either readtarget or writetarget is mapped. 

glCopyImageSubData
void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
GL_INVALID_OPERATION is generated if the texel size of the uncompressed image is not equal to the block size of the compressed image. 
GL_INVALID_ENUM is generated if either target parameter is not GL_RENDERBUFFER, a valid non-proxy texture target other than GL_TEXTURE_BUFFER, or is one of the cubemap face selectors. 
GL_INVALID_ENUM is generated if target does not match the type of the object. 
GL_INVALID_OPERATION is generated if either object is a texture and the texture is not complete. 
GL_INVALID_OPERATION is generated if the source and destination internal formats are not compatible, or if the number of samples do not match. 
GL_INVALID_VALUE is generated if either name does not correspond to a valid renderbuffer or texture object according to the corresponding target parameter. 
GL_INVALID_VALUE is generated if the specified level of either the source or destination is not a valid level for the corresponding image. 
GL_INVALID_VALUE is generated if the dimensions of the either subregion exceeds the boundaries of the corresponding image object, or if the image format is compressed and the dimensions of the subregion fail to meet the alignment constraints of the format. 

glCopyTexImage1D
void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
GL_INVALID_ENUM is generated if target is not one of the allowable values. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if internalformat is not an allowable value. 
GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32 and there is no depth buffer. 

glCopyTexImage2D
void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_VALUE is generated if internalformat is not an accepted format. 
GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32 and there is no depth buffer. 

glCopyTexSubImage1D
void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
GL_INVALID_ENUM is generated if /target is not GL_TEXTURE_1D. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D or glCopyTexImage1D operation. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level &gt;
log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset &lt;
0 , or xoffset + width &gt;
w , where w is the GL_TEXTURE_WIDTH of the texture image being modified. 


glCopyTexSubImage2D
void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D or glCopyTexImage2D operation. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level &gt;
log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset &lt;
0 , xoffset + width &gt;
w , yoffset &lt;
0 , or yoffset + height &gt;
0 , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT and of the texture image being modified. 

glCopyTexSubImage3D
void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if /target is not GL_TEXTURE_3D. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D operation. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level &gt;
log 2 ⁡ max , where max is the returned value of GL_MAX_3D_TEXTURE_SIZE if target is GL_TEXTURE_3D or the returned value of GL_MAX_ARRAY_TEXTURE_LAYERS if target is GL_TEXTURE_2D_ARRAY. 
GL_INVALID_VALUE is generated if xoffset &lt;
0 , xoffset + width &gt;
w , yoffset &lt;
0 , yoffset + height &gt;
h , zoffset &lt;
0 , or zoffset + 1 &gt;
d , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and of the texture image being modified. Note that w, h, and d include twice the border width. 

glCreateProgram
GLuint glCreateProgram(void);
This function returns 0 if an error occurs creating the program object.

glCreateShader
GLuint glCreateShader(GLenum shaderType);
This function returns 0 if an error occurs creating theshader object.
GL_INVALID_ENUM is generated ifshaderType is not an accepted value.

glCreateShaderProgramv
GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char **strings);
GL_INVALID_ENUM is generated if if type is not an accepted shader type. 
GL_INVALID_VALUE is generated if count is negative. 
Other errors are generated if the supplied shader code fails to compile and link, as described for the commands in the pseudocode sequence above, but all such errors are generated without any side effects of executing those commands. 

glCullFace
void glCullFace(GLenum mode);
GL_INVALID_ENUM is generated if mode is not an accepted value. 

glDebugMessageCallback
void glDebugMessageCallback(DEBUGPROC callback, void * userParam);

glDebugMessageControl
void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_ENUM is generated if any of source, type or severity is not one of the accepted interface types. 
GL_INVALID_OPERATION is generated if count is non-zero and either source or type is GL_DONT_CARE or if severity is not GL_DONT_CARE. 

glDebugMessageInsert
void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char *message);
GL_INVALID_ENUM is generated if any of source, type or severity is not one of the accepted interface types. 
GL_INVALID_VALUE is generated if the length of the message is greater than the value of GL_MAX_DEBUG_MESSAGE_LENGTH. 

glDeleteBuffers
void glDeleteBuffers(GLsizei n, const GLuint * buffers);
GL_INVALID_VALUE is generated if n is negative. 

glDeleteFramebuffers
void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers);
GL_INVALID_VALUE is generated if n is negative. 

glDeleteProgram
void glDeleteProgram(GLuint program);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.

glDeleteProgramPipelines
void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines);

glDeleteQueries
void glDeleteQueries(GLsizei n, const GLuint * ids);
GL_INVALID_VALUE is generated if n is negative. 

glDeleteRenderbuffers
void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers);
GL_INVALID_VALUE is generated if n is negative. 

glDeleteSamplers
void glDeleteSamplers(GLsizei n, const GLuint * samplers);
GL_INVALID_VALUE is generated if n is negative. 

glDeleteShader
void glDeleteShader(GLuint shader);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.

glDeleteSync
void glDeleteSync(GLsync sync);
GL_INVALID_VALUE is generated if sync is neither zero or the name of a sync object. 

glDeleteTextures
void glDeleteTextures(GLsizei n, const GLuint * textures);
GL_INVALID_VALUE is generated if n is negative. 

glDeleteTransformFeedbacks
void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids);

glDeleteVertexArrays
void glDeleteVertexArrays(GLsizei n, const GLuint *arrays);
GL_INVALID_VALUE is generated if n is negative. 

glDepthFunc
void glDepthFunc(GLenum func);
GL_INVALID_ENUM is generated if func is not an accepted value. 

glDepthMask
void glDepthMask(GLboolean flag);

glDepthRange
void glDepthRange(GLdouble nearVal, GLdouble farVal);

glDepthRangef
void glDepthRangef(GLfloat nearVal, GLfloat farVal);

glDepthRangeArrayv
void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble *v);
GL_INVALID_VALUE is generated if first is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if first + count is greater than or equal to the value of GL_MAX_VIEWPORTS. 

glDepthRangeIndexed
void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 

glDetachShader
void glDetachShader(GLuint program, GLuint shader);
GL_INVALID_VALUE is generated if either program or shader is a value that was not generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if shader is not a shader object.
GL_INVALID_OPERATION is generated if shader is not attached to program.

glDispatchCompute
void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
GL_INVALID_OPERATION is generated if there is no active program for the compute shader stage. 
GL_INVALID_VALUE is generated if any of num_groups_x, num_groups_y, or num_groups_z is greater than or equal to the maximum work-group count for the corresponding dimension. 

glDispatchComputeIndirect
void glDispatchComputeIndirect(GLintptr indirect);
GL_INVALID_OPERATION is generated if there is no active program for the compute shader stage. 
GL_INVALID_VALUE is generated if indirect is less than zero or not a multiple of four. 
GL_INVALID_OPERATION is generated if no buffer is bound to the GL_DISPATCH_INDIRECT_BUFFER target or if the command would source data beyond the end of the buffer object's data store. 

glDrawArrays
void glDrawArrays(GLenum mode, GLint first, GLsizei count);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 

glDrawArraysIndirect
void glDrawArraysIndirect(GLenum mode, const void *indirect);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER binding and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 

glDrawArraysInstanced
void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
GL_INVALID_ENUM is generated if mode is not one of the accepted values. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_VALUE is generated if count or primcount are negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

glDrawArraysInstancedBaseInstance
void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
GL_INVALID_ENUM is generated if mode is not one of the accepted values. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_VALUE is generated if count or primcount are negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

glDrawBuffer
void glDrawBuffer(GLenum mode);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_OPERATION is generated if none of the buffers indicated by mode exists. 

glDrawBuffers
void glDrawBuffers(GLsizei n, const GLenum *bufs);
GL_INVALID_ENUM is generated if one of the values in bufs is not an accepted value.
GL_INVALID_ENUM is generated if the GL is bound to the default framebuffer and one or more of the values in bufs is one of the GL_COLOR_ATTACHMENTn tokens.
GL_INVALID_ENUM is generated if the GL is bound to a framebuffer object and one or more of the values in bufs is anything other than GL_NONE or one of the GL_COLOR_ATTACHMENTn tokens.
GL_INVALID_ENUM is generated if n is less than 0.
GL_INVALID_OPERATION is generated if a symbolic constant other than GL_NONE appears more than once in bufs.
GL_INVALID_OPERATION is generated if any of the entries in bufs (other than GL_NONE ) indicates a color buffer that does not exist in the current GL context.
GL_INVALID_VALUE is generated if n is greater than GL_MAX_DRAW_BUFFERS.

glDrawElements
void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

glDrawElementsBaseVertex
void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

glDrawElementsIndirect
void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_OPERATION is generated if no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding, or if such a buffer's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER binding and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 

glDrawElementsInstanced
void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);
GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, or GL_TRIANGLES. 
GL_INVALID_VALUE is generated if count or primcount are negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

glDrawElementsInstancedBaseInstance
void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount, GLuitn baseinstance);
GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, or GL_TRIANGLES. 
GL_INVALID_VALUE is generated if count or primcount are negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

glDrawElementsInstancedBaseVertex
void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLsizei primcount, GLint basevertex);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count or primcount is negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

glDrawElementsInstancedBaseVertexBaseInstance
void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count or primcount is negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

glDrawRangeElements
void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices);
It is an error for indices to lie outside the range start end , but implementations may not check for this situation. Such indices cause implementation-dependent behavior. 
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_VALUE is generated if end &lt;
start . 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

glDrawRangeElementsBaseVertex
void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_VALUE is generated if end &lt;
start. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

glDrawTransformFeedback
void glDrawTransformFeedback(GLenum mode, GLuint id);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if id is not the name of a transform feedback object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback has never been called while the transform feedback object named by id was bound. 

glDrawTransformFeedbackInstanced
void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if id is not the name of a transform feedback object. 
GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback has never been called while the transform feedback object named by id was bound. 

glDrawTransformFeedbackStream
void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if id is not the name of a transform feedback object. 
GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback has never been called while the transform feedback object named by id was bound. 

glDrawTransformFeedbackStreamInstanced
void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if id is not the name of a transform feedback object. 
GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback has never been called while the transform feedback object named by id was bound. 

glEnable
void glEnable(GLenum cap);
GL_INVALID_ENUM is generated if cap is not one of the values listed previously. 
GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities for cap. 

glDisable
void glDisable(GLenum cap);
GL_INVALID_ENUM is generated if cap is not one of the values listed previously. 
GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities for cap. 

glEnablei
void glEnablei(GLenum cap, GLuint index);
GL_INVALID_ENUM is generated if cap is not one of the values listed previously. 
GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities for cap. 

glDisablei
void glDisablei(GLenum cap, GLuint index);
GL_INVALID_ENUM is generated if cap is not one of the values listed previously. 
GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities for cap. 

glEnableVertexAttribArray
void glEnableVertexAttribArray(GLuint index);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.

glDisableVertexAttribArray
void glDisableVertexAttribArray(GLuint index);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.

glFenceSync
GLsync glFenceSync(GLenum condition, GLbitfield flags);
GL_INVALID_ENUM is generated if condition is not GL_SYNC_GPU_COMMANDS_COMPLETE. 
GL_INVALID_VALUE is generated if flags is not zero. 
Additionally, if glFenceSync fails, it will return zero. 

glFinish
void glFinish( void);

glFlush
void glFlush( void);

glFlushMappedBufferRange
void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length exceeds the size of the mapping. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if the buffer bound to target is not mapped, or is mapped without the GL_MAP_FLUSH_EXPLICIT_BIT flag. 

glFramebufferParameteri
void glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
GL_INVALID_ENUM is generated if target is not one of the accepted framebuffer targets. 
GL_INVAILD_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_WIDTH and param is less than zero or greater than the value of GL_MAX_FRAMEBUFFER_WIDTH. 
GL_INVAILD_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_HEIGHT and param is less than zero or greater than the value of GL_MAX_FRAMEBUFFER_HEIGHT. 
GL_INVAILD_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_LAYERS and param is less than zero or greater than the value of GL_MAX_FRAMEBUFFER_LAYERS. 
GL_INVAILD_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_SAMPLES and param is less than zero or greater than the value of GL_MAX_FRAMEBUFFER_SAMPLES. 
GL_INVALID_OPERATION is generated if the default framebuffer is bound to target. 

glFramebufferRenderbuffer
void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 

glFramebufferTexture
void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if textarget and texture are not compatible. 

glFramebufferTexture1D
void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if textarget and texture are not compatible. 

glFramebufferTexture2D
void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if textarget and texture are not compatible. 

glFramebufferTexture3D
void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if textarget and texture are not compatible. 

glFramebufferTextureLayer
void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if attachment is not one of the accepted tokens. 
GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object. 
GL_INVALID_VALUE is generated if texture is not zero and layer is negative. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if texture is not zero or the name of an existing cube map texture. 

glFrontFace
void glFrontFace(GLenum mode);
GL_INVALID_ENUM is generated if mode is not an accepted value. 

glGenBuffers
void glGenBuffers(GLsizei n, GLuint * buffers);
GL_INVALID_VALUE is generated if n is negative. 

glGenFramebuffers
void glGenFramebuffers(GLsizei n, GLuint *ids);
GL_INVALID_VALUE is generated if n is negative. 

glGenProgramPipelines
void glGenProgramPipelines(GLsizei n, GLuint *pipelines);

glGenQueries
void glGenQueries(GLsizei n, GLuint * ids);
GL_INVALID_VALUE is generated if n is negative. 

glGenRenderbuffers
void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);
GL_INVALID_VALUE is generated if n is negative. 

glGenSamplers
void glGenSamplers(GLsizei n, GLuint *samplers);
GL_INVALID_VALUE is generated if n is negative. 

glGenTextures
void glGenTextures(GLsizei n, GLuint * textures);
GL_INVALID_VALUE is generated if n is negative. 

glGenTransformFeedbacks
void glGenTransformFeedbacks(GLsizei n, GLuint *ids);

glGenVertexArrays
void glGenVertexArrays(GLsizei n, GLuint *arrays);
GL_INVALID_VALUE is generated if n is negative. 

glGenerateMipmap
void glGenerateMipmap(GLenum target);
GL_INVALID_ENUM is generated if target is not one of the accepted texture targets. 
GL_INVALID_OPERATION is generated if target is GL_TEXTURE_CUBE_MAP and the texture bound to the GL_TEXTURE_CUBE_MAP target of the active texture unit is not cube complete. 

glGetBooleanv
void glGetBooleanv(GLenum pname, GLboolean * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetDoublev
void glGetDoublev(GLenum pname, GLdouble * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetFloatv
void glGetFloatv(GLenum pname, GLfloat * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetIntegerv
void glGetIntegerv(GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetInteger64v
void glGetInteger64v(GLenum pname, GLint64 * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetBooleani_v
void glGetBooleani_v(GLenum pname, GLuint index, GLboolean * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetIntegeri_v
void glGetIntegeri_v(GLenum pname, GLuint index, GLint * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetFloati_v
void glGetFloati_v(GLenum pname, GLuint index, GLfloat * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetDoublei_v
void glGetDoublei_v(GLenum pname, GLuint index, GLdouble * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetInteger64i_v
void glGetInteger64i_v(GLenum pname, GLuint index, GLint64 * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

glGetActiveAtomicCounterBufferiv
void glGetActiveAtomicCounterBufferiv(Gluint program, GLuint bufferIndex, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 
GL_INVALID_VALUE is generated if bufferIndex is greater than or equal to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for program. 
GL_INVALID_ENUM is generated if pname is not one of the accepted tokens. 

glGetActiveAttrib
void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if index is greater than or equal to the number of active attribute variables in program.
GL_INVALID_VALUE is generated if bufSize is less than 0.

glGetActiveSubroutineName
void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINES. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

glGetActiveSubroutineUniformiv
void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINES. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

glGetActiveSubroutineUniformName
void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINES. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

glGetActiveUniform
void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if index is greater than or equal to the number of active uniform variables in program.
GL_INVALID_VALUE is generated if bufSize is less than 0.

glGetActiveUniformBlockiv
void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if uniformBlockIndex is greater than or equal to the value of GL_ACTIVE_UNIFORM_BLOCKS or is not the index of an active uniform block in program. 
GL_INVALID_ENUM is generated if pname is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 

glGetActiveUniformBlockName
void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 
GL_INVALID_VALUE is generated if uniformBlockIndex is greater than or equal to the value of GL_ACTIVE_UNIFORM_BLOCKS or is not the index of an active uniform block in program. 

glGetActiveUniformName
void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
GL_INVALID_VALUE is generated if uniformIndex is greater than or equal to the value of GL_ACTIVE_UNIFORMS. 
GL_INVALID_VALUE is generated if bufSize is negative. 
GL_INVALID_VALUE is generated if program is not the name of a program object for which glLinkProgram has been issued. 

glGetActiveUniformsiv
void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if uniformCount is greater than or equal to the value of GL_ACTIVE_UNIFORMS for program.
GL_INVALID_ENUM is generated if pname is not an accepted token.

glGetAttachedShaders
void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if maxCount is less than 0.

glGetAttribLocation
GLint glGetAttribLocation(GLuint program, const GLchar *name);
GL_INVALID_OPERATION is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.

glGetBufferParameteriv
void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data);
GL_INVALID_ENUM is generated if target or value is not an accepted value. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 

glGetBufferParameteri64v
void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data);
GL_INVALID_ENUM is generated if target or value is not an accepted value. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 

glGetBufferPointerv
void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid ** params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 

glGetBufferSubData
void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER. 
GL_INVALID_VALUE is generated if offset or size is negative, or if together they define a region of memory that extends beyond the buffer object's allocated data store. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_INVALID_OPERATION is generated if the buffer object being queried is mapped. 

glGetCompressedTexImage
void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid * img);
GL_INVALID_VALUE is generated if lod is less than zero or greater than the maximum number of LODs permitted by the implementation. 
GL_INVALID_OPERATION is generated if glGetCompressedTexImage is used to retrieve a texture that is in an uncompressed internal format. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size. 

glGetDebugMessageLog
GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum *sources, Glenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
GL_INVALID_VALUE is generated if count or bufSize is negative. 

glGetError
GLenum glGetError( void);

glGetFragDataIndex
GLint glGetFragDataIndex(GLuint program, const char * name);
GL_INVALID_OPERATION is generated if program is not the name of a program object. 

glGetFragDataLocation
GLint glGetFragDataLocation(GLuint program, const char * name);
GL_INVALID_OPERATION is generated if program is not the name of a program object. 

glGetFramebufferAttachmentParameteriv
void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if pname is not valid for the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE. 
GL_INVALID_OPERATION is generated if attachment is not the accepted values for target. 
GL_INVALID_OPERATION is generated if attachment is GL_DEPTH_STENCIL_ATTACHMENT and different objects are bound to the depth and stencil attachment points of target. 
GL_INVALID_OPERATION is generated if the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE and pname is not GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME. 

glGetFramebufferParameteriv
void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target is not one of the accepted framebuffer targets. 
GL_INVALID_ENUM is generated if pname is not one of the accepted parameter names. 
GL_INVALID_OPERATION is generated if the default framebuffer is bound to target. 
params should be the address of a variable to which the client has write access otherwise undefined behavior, including process termination may occur. 

glGetInternalformativ
void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
GL_INVALID_VALUE is generated if bufSize is negative. 
GL_INVALID_ENUM is generated if pname is not GL_SAMPLES or GL_NUM_SAMPLE_COUNTS. 
GL_INVALID_ENUM is generated if internalformat is not color-, depth-, or stencil-renderable. 
GL_INVALID_ENUM is generated if target is not one of GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_RENDERBUFFER. 

glGetInternalformati64v
void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
GL_INVALID_VALUE is generated if bufSize is negative. 
GL_INVALID_ENUM is generated if pname is not GL_SAMPLES or GL_NUM_SAMPLE_COUNTS. 
GL_INVALID_ENUM is generated if internalformat is not color-, depth-, or stencil-renderable. 
GL_INVALID_ENUM is generated if target is not one of GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_RENDERBUFFER. 

glGetMultisamplefv
void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val);
GL_INVALID_ENUM is generated if pname is not one GL_SAMPLE_POSITION. 
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_SAMPLES. 

glGetObjectLabel
void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bifSize, GLsizei * length, char * label);
GL_INVALID_ENUM is generated if identifier is not one of the accepted object types. 
GL_INVALID_OPERATION is generated if name is not the name of an existing object of the type specified by identifier. 
GL_INVALID_VALUE is generated if bufSize is zero. 
If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur. 

glGetObjectPtrLabel
void glGetObjectPtrLabel(void * ptr, GLsizei bifSize, GLsizei * length, char * label);
GL_INVALID_ENUM is generated if identifier is not one of the accepted object types. 
GL_INVALID_VALUE is generated if ptr is not the name of an existing sync object. 
GL_INVALID_VALUE is generated if bufSize is zero. 
If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur. 

glGetProgramiv
void glGetProgramiv(GLuint program, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program does not refer to a program object.
GL_INVALID_OPERATION is generated if pname is GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, or GL_GEOMETRY_OUTPUT_TYPE, and program does not contain a geometry shader.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if pname is GL_COMPUTE_WORK_GROUP_SIZE and program does not contain a binary for the compute shader stage.

glGetProgramBinary
void glGetProgramBinary(GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary);
GL_INVALID_OPERATION is generated if bufSize is less than the size of GL_PROGRAM_BINARY_LENGTH for program. 
GL_INVALID_OPERATION is generated if GL_LINK_STATUS for the program object is false. 

glGetProgramInfoLog
void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog);
GL_INVALID_VALUE is generated ifprogram is not a value generated byOpenGL.
GL_INVALID_OPERATION is generated ifprogram is not a program object.
GL_INVALID_VALUE is generated ifmaxLength is less than 0.

glGetProgramInterfaceiv
void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if identifier is not one of the accepted object types. 
GL_INVALID_VALUE is generated if program is not the name of an existing sync object. 
GL_INVALID_VALUE is generated if bufSize is zero. 
GL_INVALID_OPERATION is generated if pname is GL_MAX_NAME_LENGTH and programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active atomic counter and transform feedback buffer resources are not assigned name strings. 
GL_INVALID_OPERATION error is generated if pname is GL_MAX_NUM_ACTIVE_VARIABLES and programInterface is not GL_UNIFORM_BLOCK, GL_SHADER_STORAGE_BLOCK, GL_ATOMIC_COUNTER_BUFFER, or GL_TRANSFORM_FEEDBACK_BUFFER. 
If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur. 

glGetProgramPipelineiv
void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params);
GL_INVALID_OPERATION is generated if pipeline is not zero or a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 
GL_INVALID_ENUM is generated if pname is not one of the accepted values. 

glGetProgramPipelineInfoLog
void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 

glGetProgramResourceiv
void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const Glenum * props, GLsizei bufSize, GLsizei * length, GLint * params);
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 
GL_INVALID_VALUE is generated if propCount is zero. 
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVLALID_ENUM is generated if any value in props is not one of the accepted tokens for the interface programInterface 

glGetProgramResourceIndex
GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name);
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVALID_ENUM is generated if programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active atomic counter and transform feedback buffer resources are not assigned name strings. 
Although not an error, GL_INVALID_INDEX is returned if name is not the name of a resource within the interface identified by programInterface. 

glGetProgramResourceLocation
GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name);
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVALID_OPERATION is generated if program has not been linked successfully. 

glGetProgramResourceLocationIndex
GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name);
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVALID_OPERATION is generated if program has not been linked successfully. 

glGetProgramResourceName
void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name);
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVALID_VALUE is generated if progam is not the name of an existing program. 
GL_INVALID_VALUE is generated if index is greater than or equal to the number of entries in the active resource list for programInterface. 
GL_INVALID_ENUM is generated if programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active atomic counter and transform feedback buffer resources are not assigned name strings. 

glGetProgramStageiv
void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint *values);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

glGetQueryIndexediv
void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 
GL_INVALID_VALUE is generated if index is greater than or equal to the target-specific maximum. 

glGetQueryObjectiv
void glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_OPERATION is generated if id is not the name of a query object. 
GL_INVALID_OPERATION is generated if id is the name of a currently active query object. 
GL_INVALID_OPERATION is generated if a buffer is currently bound to the GL_QUERY_RESULT_BUFFER target and the command would cause data to be written beyond the bounds of that buffer's data store. 

glGetQueryObjectuiv
void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_OPERATION is generated if id is not the name of a query object. 
GL_INVALID_OPERATION is generated if id is the name of a currently active query object. 
GL_INVALID_OPERATION is generated if a buffer is currently bound to the GL_QUERY_RESULT_BUFFER target and the command would cause data to be written beyond the bounds of that buffer's data store. 

glGetQueryObjecti64v
void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_OPERATION is generated if id is not the name of a query object. 
GL_INVALID_OPERATION is generated if id is the name of a currently active query object. 
GL_INVALID_OPERATION is generated if a buffer is currently bound to the GL_QUERY_RESULT_BUFFER target and the command would cause data to be written beyond the bounds of that buffer's data store. 

glGetQueryObjectui64v
void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_OPERATION is generated if id is not the name of a query object. 
GL_INVALID_OPERATION is generated if id is the name of a currently active query object. 
GL_INVALID_OPERATION is generated if a buffer is currently bound to the GL_QUERY_RESULT_BUFFER target and the command would cause data to be written beyond the bounds of that buffer's data store. 

glGetQueryiv
void glGetQueryiv(GLenum target, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

glGetRenderbufferParameteriv
void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params);
GL_INVALID_ENUM is generated if pname is not one of the accepted tokens. 

glGetSamplerParameterfv
void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object returned from a previous call to glGenSamplers. 
GL_INVALID_ENUM is generated if pname is not an accepted value. 

glGetSamplerParameteriv
void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object returned from a previous call to glGenSamplers. 
GL_INVALID_ENUM is generated if pname is not an accepted value. 

glGetSamplerParameterIiv
void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object returned from a previous call to glGenSamplers. 
GL_INVALID_ENUM is generated if pname is not an accepted value. 

glGetSamplerParameterIuiv
void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object returned from a previous call to glGenSamplers. 
GL_INVALID_ENUM is generated if pname is not an accepted value. 

glGetShaderiv
void glGetShaderiv(GLuint shader, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated ifshader is not a value generated byOpenGL.
GL_INVALID_OPERATION is generated ifshader does not refer to a shaderobject.
GL_INVALID_ENUM is generated ifpname is not an accepted value.

glGetShaderInfoLog
void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog);
GL_INVALID_VALUE is generated ifshader is not a value generated byOpenGL.
GL_INVALID_OPERATION is generated ifshader is not a shader object.
GL_INVALID_VALUE is generated ifmaxLength is less than 0.

glGetShaderPrecisionFormat
void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision);
GL_INVALID_ENUM is generated if shaderType or precisionType is not an accepted value. 

glGetShaderSource
void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if shader is not a shader object.
GL_INVALID_VALUE is generated if bufSize is less than 0.

glGetString
const GLubyte* glGetString(GLenum name);
GL_INVALID_ENUM is generated if name is not an accepted value. 
GL_INVALID_VALUE is generated by glGetStringi if index is outside the valid range for indexed state name. 

glGetStringi
const GLubyte* glGetStringi(GLenum name, GLuint index);
GL_INVALID_ENUM is generated if name is not an accepted value. 
GL_INVALID_VALUE is generated by glGetStringi if index is outside the valid range for indexed state name. 

glGetSubroutineIndex
GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

glGetSubroutineUniformLocation
GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar *name);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

glGetSynciv
void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
GL_INVALID_VALUE is generated if sync is not the name of a sync object. 
GL_INVALID_ENUM is generated if pname is not one of the accepted tokens. 

glGetTexImage
void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * img);
GL_INVALID_ENUM is generated if target, format, or type is not an accepted value. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV and format is neither GL_RGBA or GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX or GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and img is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

glGetTexLevelParameterfv
void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_BUFFER and level is not zero. 
GL_INVALID_OPERATION is generated if GL_TEXTURE_COMPRESSED_IMAGE_SIZE is queried on texture images with an uncompressed internal format or on proxy targets. 

glGetTexLevelParameteriv
void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_BUFFER and level is not zero. 
GL_INVALID_OPERATION is generated if GL_TEXTURE_COMPRESSED_IMAGE_SIZE is queried on texture images with an uncompressed internal format or on proxy targets. 

glGetTexParameterfv
void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

glGetTexParameteriv
void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

glGetTexParameterIiv
void glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

glGetTexParameterIuiv
void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

glGetTransformFeedbackVarying
void glGetTransformFeedbackVarying(GLuintprogram, GLuintindex, GLsizeibufSize, GLsizei *length, GLsizei *size, GLenum *type, char *name);
GL_INVALID_VALUE is generated if program is not the name of a program object. 
GL_INVALID_VALUE is generated if index is greater or equal to the value of GL_TRANSFORM_FEEDBACK_VARYINGS. 
GL_INVALID_OPERATION is generated program has not been linked. 

glGetUniformfv
void glGetUniformfv(GLuint program, GLint location, GLfloat *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.
GL_INVALID_OPERATION is generated if location does not correspond to a valid uniform variable location for the specified program object.

glGetUniformiv
void glGetUniformiv(GLuint program, GLint location, GLint *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.
GL_INVALID_OPERATION is generated if location does not correspond to a valid uniform variable location for the specified program object.

glGetUniformuiv
void glGetUniformuiv(GLuint program, GLint location, GLuint *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.
GL_INVALID_OPERATION is generated if location does not correspond to a valid uniform variable location for the specified program object.

glGetUniformdv
void glGetUniformdv(GLuint program, GLint location, GLdouble *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.
GL_INVALID_OPERATION is generated if location does not correspond to a valid uniform variable location for the specified program object.

glGetUniformBlockIndex
GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName);
GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 

glGetUniformIndices
void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices);
GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 

glGetUniformLocation
GLint glGetUniformLocation(GLuint program, const GLchar *name);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.

glGetUniformSubroutineuiv
void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint *values);
GL_INVALID_ENUM is generated if shadertype is not one of the accepted values. 
GL_INVALID_VALUE is generated if location is greater than or equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader currently in use at shader stage shadertype. 
GL_INVALID_OPERATION is generated if no program is active. 

glGetVertexAttribdv
void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

glGetVertexAttribfv
void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

glGetVertexAttribiv
void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

glGetVertexAttribIiv
void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

glGetVertexAttribIuiv
void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

glGetVertexAttribLdv
void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

glGetVertexAttribPointerv
void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer);
GL_INVALID_OPERATION is generated if no vertex array object is currently bound.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.

glHint
void glHint(GLenum target, GLenum mode);
GL_INVALID_ENUM is generated if either target or mode is not an accepted value. 

glInvalidateBufferData
void glInvalidateBufferData(GLuint buffer);
GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object. 
GL_INVALID_OPERATION is generated if any part of buffer is currently mapped. 

glInvalidateBufferSubData
void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);
GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length is greater than the value of GL_BUFFER_SIZE for buffer. 
GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object. 
GL_INVALID_OPERATION is generated if any part of buffer is currently mapped. 

glInvalidateFramebuffer
void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments);
GL_INVALID_ENUM is generated if target is not one of the accepted framebuffer target tokens. 
GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment tokens. 
GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTi where i is greater than or equal to the value of GL_MAX_COLOR_ATTACHMENTS. 

glInvalidateSubFramebuffer
void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height);
GL_INVALID_ENUM is generated if target is not one of the accepted framebuffer target tokens. 
GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment tokens. 
GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTi where i is greater than or equal to the value of GL_MAX_COLOR_ATTACHMENTS. 

glInvalidateTexImage
void glInvalidateTexImage(GLuint texture, GLint level);
GL_INVALID_VALUE is generated if level is less than zero or if it is greater or equal to the base 2 logarithm of the maximum texture width, height, or depth. 
GL_INVALID_VALUE is generated if the target of texture is any of GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and level is not zero. 
GL_INVALID_VALUE is generated if texture is not the name of an existing texture object. 

glInvalidateTexSubImage
void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
GL_INVALID_VALUE is generated if xoffset, yoffset or zoffset is less than zero, or if any of them is greater than the size of the image in the corresponding dimension. 
GL_INVALID_VALUE is generated if level is less than zero or if it is greater or equal to the base 2 logarithm of the maximum texture width, height, or depth. 
GL_INVALID_VALUE is generated if the target of texture is any of GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and level is not zero. 
GL_INVALID_VALUE is generated if texture is not the name of an existing texture object. 

glIsBuffer
GLboolean glIsBuffer(GLuint buffer);

glIsEnabled
GLboolean glIsEnabled(GLenum cap);
GL_INVALID_ENUM is generated if cap is not an accepted value. 
GL_INVALID_VALUE is generated by glIsEnabledi if index is outside the valid range for the indexed state cap. 

glIsEnabledi
GLboolean glIsEnabledi(GLenum cap, GLuint index);
GL_INVALID_ENUM is generated if cap is not an accepted value. 
GL_INVALID_VALUE is generated by glIsEnabledi if index is outside the valid range for the indexed state cap. 

glIsFramebuffer
GLboolean glIsFramebuffer(GLuint framebuffer);

glIsProgram
GLboolean glIsProgram(GLuint program);

glIsProgramPipeline
GLboolean glIsProgramPipeline(GLuint pipeline);

glIsQuery
GLboolean glIsQuery(GLuint id);

glIsRenderbuffer
GLboolean glIsRenderbuffer(GLuint renderbuffer);

glIsSampler
GLboolean glIsSampler(GLuint id);

glIsShader
GLboolean glIsShader(GLuint shader);

glIsSync
GLboolean glIsSync(GLsync sync);

glIsTexture
GLboolean glIsTexture(GLuint texture);

glIsTransformFeedback
GLboolean glIsTransformFeedback(GLuint id);

glIsVertexArray
GLboolean glIsVertexArray(GLuint array);

glLineWidth
void glLineWidth(GLfloat width);
GL_INVALID_VALUE is generated if width is less than or equal to 0. 

glLinkProgram
void glLinkProgram(GLuint program);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program is the currently active program object and transform feedback mode is active.

glLogicOp
void glLogicOp(GLenum opcode);
GL_INVALID_ENUM is generated if opcode is not an accepted value. 

glMapBuffer
void * glMapBuffer(GLenum target, GLenum access);
GL_INVALID_ENUM is generated if target is not one of the accepted targets. 
GL_INVALID_ENUM is generated if access is not GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. 
GL_OUT_OF_MEMORY is generated when glMapBuffer is executed if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific reasons, such as the absence of sufficient remaining virtual memory. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_INVALID_OPERATION is generated if glMapBuffer is executed for a buffer object whose data store is already mapped. 
GL_INVALID_OPERATION is generated if glUnmapBuffer is executed for a buffer object whose data store is not currently mapped. 

glUnmapBuffer
GLboolean glUnmapBuffer(GLenum target);
GL_INVALID_ENUM is generated if target is not one of the accepted targets. 
GL_INVALID_ENUM is generated if access is not GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. 
GL_OUT_OF_MEMORY is generated when glMapBuffer is executed if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific reasons, such as the absence of sufficient remaining virtual memory. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_INVALID_OPERATION is generated if glMapBuffer is executed for a buffer object whose data store is already mapped. 
GL_INVALID_OPERATION is generated if glUnmapBuffer is executed for a buffer object whose data store is not currently mapped. 

*glMapBufferRange
void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
GL_INVALID_VALUE is generated if either of offset or length is negative, or if offset + length is greater than the value of GL_BUFFER_SIZE. 
GL_INVALID_VALUE is generated if access has any bits set other than those defined above. 
GL_INVALID_OPERATION is generated for any of the following conditions: 
The buffer is already in a mapped state. 
Neither GL_MAP_READ_BIT or GL_MAP_WRITE_BIT is set. 
GL_MAP_READ_BIT is set and any of GL_MAP_INVALIDATE_RANGE_BIT, GL_MAP_INVALIDATE_BUFFER_BIT, or GL_MAP_UNSYNCHRONIZED_BIT is set. 
GL_MAP_FLUSH_EXPLICIT_BIT is set and GL_MAP_WRITE_BIT is not set. 
Any of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, or GL_MAP_COHERENT_BIT are included in access, but the same bit is not included in the buffer's storage flags. 

GL_OUT_OF_MEMORY is generated if glMapBufferRange fails because memory for the mapping could not be obtained. 

glMemoryBarrier
void glMemoryBarrier(GLbitfield barriers);
GL_INVALID_VALUE is generated if barriers contains any unsupported bits, or is not the special value GL_ALL_BARRIER_BITS. 

glMinSampleShading
void glMinSampleShading(GLfloat value);
None. 

glMultiDrawArrays
void glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

glMultiDrawArraysIndirect
void glMultiDrawArraysIndirect(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if stride is not a multiple of four. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER binding and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 

glMultiDrawElements
void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

glMultiDrawElementsBaseVertex
void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei drawcount, const GLint *basevertex);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

glMultiDrawElementsIndirect
void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if stride is not a multiple of four. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding, or if such a buffer's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER binding and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 

glObjectLabel
void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label);
GL_INVALID_ENUM is generated if identifier is not one of the accepted object types. 
GL_INVALID_OPERATION is generated if name is not the name of an existing object of the type specified by identifier. 
GL_INVALID_VALUE is generated if the number of characters in label, excluding the null terminator when length is negative, is greater than the value of GL_MAX_LABEL_LENGTH. 

glObjectPtrLabel
void glObjectPtrLabel(void * ptr, GLsizei length, const char * label);
GL_INVALID_VALUE is generated if ptr is not a valid sync object. 
GL_INVALID_VALUE is generated if the number of characters in label, excluding the null terminator when length is negative, is greater than the value of GL_MAX_LABEL_LENGTH. 

glPatchParameteri
void glPatchParameteri(GLenum pname, GLint value);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated if pname is GL_PATCH_VERTICES and value is less than or equal to zero, or greater than the value of GL_MAX_PATCH_VERTICES. 

glPatchParameterfv
void glPatchParameterfv(GLenum pname, const GLfloat *values);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated if pname is GL_PATCH_VERTICES and value is less than or equal to zero, or greater than the value of GL_MAX_PATCH_VERTICES. 

glPauseTransformFeedback
void glPauseTransformFeedback(void);
GL_INVALID_OPERATION is generated if the currently bound transform feedback object is not active or is paused. 

glPixelStoref
void glPixelStoref(GLenum pname, GLfloat param);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated if a negative row length, pixel skip, or row skip value is specified, or if alignment is specified as other than 1, 2, 4, or 8. 

glPixelStorei
void glPixelStorei(GLenum pname, GLint param);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated if a negative row length, pixel skip, or row skip value is specified, or if alignment is specified as other than 1, 2, 4, or 8. 

glPointParameterf
void glPointParameterf(GLenum pname, GLfloat param);
GL_INVALID_VALUE is generated if the value specified for GL_POINT_FADE_THRESHOLD_SIZE is less than zero. 
GL_INVALID_ENUM is generated If the value specified for GL_POINT_SPRITE_COORD_ORIGIN is not GL_LOWER_LEFT or GL_UPPER_LEFT. 

glPointParameteri
void glPointParameteri(GLenum pname, GLint param);
GL_INVALID_VALUE is generated if the value specified for GL_POINT_FADE_THRESHOLD_SIZE is less than zero. 
GL_INVALID_ENUM is generated If the value specified for GL_POINT_SPRITE_COORD_ORIGIN is not GL_LOWER_LEFT or GL_UPPER_LEFT. 

glPointParameterfv
void glPointParameterfv(GLenum pname, const GLfloat * params);
GL_INVALID_VALUE is generated if the value specified for GL_POINT_FADE_THRESHOLD_SIZE is less than zero. 
GL_INVALID_ENUM is generated If the value specified for GL_POINT_SPRITE_COORD_ORIGIN is not GL_LOWER_LEFT or GL_UPPER_LEFT. 

glPointParameteriv
void glPointParameteriv(GLenum pname, const GLint * params);
GL_INVALID_VALUE is generated if the value specified for GL_POINT_FADE_THRESHOLD_SIZE is less than zero. 
GL_INVALID_ENUM is generated If the value specified for GL_POINT_SPRITE_COORD_ORIGIN is not GL_LOWER_LEFT or GL_UPPER_LEFT. 

glPointSize
void glPointSize(GLfloat size);
GL_INVALID_VALUE is generated if size is less than or equal to 0. 

glPolygonMode
void glPolygonMode(GLenum face, GLenum mode);
GL_INVALID_ENUM is generated if either face or mode is not an accepted value. 

glPolygonOffset
void glPolygonOffset(GLfloat factor, GLfloat units);

glPopDebugGroup
void glPopDebugGroup(void);
GL_STACK_UNDERFLOW is generated if an attempt is made to pop the default debug group from the stack. 

glPrimitiveRestartIndex
void glPrimitiveRestartIndex(GLuint index);

glProgramBinary
void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
GL_INVALID_OPERATION is generated if program is not the name of an existing program object. 
GL_INVALID_ENUM is generated if binaryFormat is not a value recognized by the implementation. 

glProgramParameteri
void glProgramParameteri(GLuint program, GLenum pname, GLint value);
GL_INVALID_OPERATION is generated if program is not the name of an existing program object. 
GL_INVALID_ENUM is generated if pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if value is not a valid value for the parameter named by pname. 

glProgramUniform1f
void glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform2f
void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform3f
void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform4f
void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform1i
void glProgramUniform1i(GLuint program, GLint location, GLint v0);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform2i
void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform3i
void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform4i
void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform1ui
void glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform2ui
void glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform3ui
void glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform4ui
void glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform1fv
void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform2fv
void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform3fv
void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform4fv
void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform1iv
void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform2iv
void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform3iv
void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform4iv
void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform1uiv
void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform2uiv
void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform3uiv
void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniform4uiv
void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix2fv
void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix3fv
void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix4fv
void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix2x3fv
void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix3x2fv
void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix2x4fv
void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix4x2fv
void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix3x4fv
void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProgramUniformMatrix4x3fv
void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

glProvokingVertex
void glProvokingVertex(GLenum provokeMode);
GL_INVALID_ENUM is generated if provokeMode is not an accepted value. 

glPushDebugGroup
void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message);
GL_INVALID_ENUM is generated if the value of source is neither GL_DEBUG_SOURCE_APPLICATION nor GL_DEBUG_SOURCE_THIRD_PARTY. 
GL_INVALID_VALUE is generated if length is negative and the number of characters in message, excluding the null-terminator, is not less than the value of GL_MAX_DEBUG_MESSAGE_LENGTH. 

glQueryCounter
void glQueryCounter(GLuint id, GLenum target);
GL_INVALID_OPERATION is generated if id is the name of a query object that is already in use within a glBeginQuery / glEndQuery block. 
GL_INVALID_VALUE is generated if id is not the name of a query object returned from a previous call to glGenQueries. 
GL_INVALID_ENUM is generated if target is not GL_TIMESTAMP. 

glReadBuffer
void glReadBuffer(GLenum mode);
GL_INVALID_ENUM is generated if mode is not one of the twelve (or more) accepted values. 
GL_INVALID_OPERATION is generated if mode specifies a buffer that does not exist. 

glReadPixels
void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * data);
GL_INVALID_ENUM is generated if format or type is not an accepted value. 
GL_INVALID_VALUE is generated if either width or height is negative. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and there is no stencil buffer. 
GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and there is no depth buffer. 
GL_INVALID_OPERATION is generated if format is GL_DEPTH_STENCIL and there is no depth buffer or if there is no stencil buffer. 
GL_INVALID_ENUM is generated if format is GL_DEPTH_STENCIL and type is not GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 
GL_INVALID_OPERATION is generated if GL_READ_FRAMEBUFFER_BINDING is non-zero, the read framebuffer is complete, and the value of GL_SAMPLE_BUFFERS for the read framebuffer is greater than zero. 

glReleaseShaderCompiler
void glReleaseShaderCompiler(void);

glRenderbufferStorage
void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER. 
GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE. 
GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format. 
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size. 

glRenderbufferStorageMultisample
void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER. 
GL_INVALID_VALUE is generated if samples is greater than GL_MAX_SAMPLES. 
GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format. 
GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the value of GL_MAX_INTEGER_SAMPLES 
GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE. 
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size. 

glResumeTransformFeedback
void glResumeTransformFeedback(void);
GL_INVALID_OPERATION is generated if the currently bound transform feedback object is not active or is not paused. 

glSampleCoverage
void glSampleCoverage(GLfloat value, GLboolean invert);

glSampleMaski
void glSampleMaski(GLuint maskNumber, GLbitfield mask);
GL_INVALID_VALUE is generated if maskIndex is greater than or equal to the value of GL_MAX_SAMPLE_MASK_WORDS. 

glSamplerParameterf
void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glSamplerParameteri
void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glSamplerParameterfv
void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glSamplerParameteriv
void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glSamplerParameterIiv
void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glSamplerParameterIuiv
void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glScissor
void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
GL_INVALID_VALUE is generated if either width or height is negative. 

glScissorArrayv
void glScissorArrayv(GLuint first, GLsizei count, const GLint *v);
GL_INVALID_VALUE is generated if first is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if first + count is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if any width or height specified in the array v is negative. 

glScissorIndexed
void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if any width or height specified in the array v is negative. 

glScissorIndexedv
void glScissorIndexedv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if any width or height specified in the array v is negative. 

glShaderBinary
void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
GL_INVALID_OPERATION is generated if more than one of the handles in shaders refers to the same shader object. 
GL_INVALID_ENUM is generated if binaryFormat is not an accepted value. 
GL_INVALID_VALUE is generated if the data pointed to by binary does not match the format specified by binaryFormat. 

glShaderSource
void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length);
GL_INVALID_VALUE is generated ifshader is not a value generated byOpenGL.
GL_INVALID_OPERATION is generated ifshader is not a shader object.
GL_INVALID_VALUE is generated ifcount is less than 0.

glShaderStorageBlockBinding
void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVAILD_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

glStencilFunc
void glStencilFunc(GLenum func, GLint ref, GLuint mask);
GL_INVALID_ENUM is generated if func is not one of the eight accepted values. 

glStencilFuncSeparate
void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
GL_INVALID_ENUM is generated if func is not one of the eight accepted values. 

glStencilMask
void glStencilMask(GLuint mask);

glStencilMaskSeparate
void glStencilMaskSeparate(GLenum face, GLuint mask);
GL_INVALID_ENUM is generated if face is not one of the accepted tokens. 

glStencilOp
void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);
GL_INVALID_ENUM is generated if sfail, dpfail, or dppass is any value other than the defined constant values. 

glStencilOpSeparate
void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
GL_INVALID_ENUM is generated if face is any value other than GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. 
GL_INVALID_ENUM is generated if sfail, dpfail, or dppass is any value other than the eight defined constant values. 

glTexBuffer
void glTexBuffer(GLenum target, GLenum internalFormat, GLuint buffer);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_BUFFER. 
GL_INVALID_ENUM is generated if internalFormat is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if buffer is not zero or the name of an existing buffer object. 

glTexBufferRange
void glTexBufferRange(GLenum target, GLenum internalFormat, GLuint buffer, GLintptr offset, GLsizeiptr size);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_BUFFER. 
GL_INVALID_VALUE is generated if offset is less than zero. 
GL_INVALID_VALUE is generated if size is less than or equal to zero. 
GL_INVALID_VALUE is generated if offset + size is greater than the value of GL_BUFFER_SIZE for buffer. 
GL_INVALID_VALUE is generated if offset is not an integer multiple of the value of GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT. 

glTexImage1D
void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. Format constants other than GL_STENCIL_INDEX are accepted. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if internalFormat is not one of the accepted resolution and format symbolic constants. 
GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and internalFormat is not GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32. 
GL_INVALID_OPERATION is generated if internalFormat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32, and format is not GL_DEPTH_COMPONENT. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

glTexImage2D
void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. 
GL_INVALID_ENUM is generated if target is one of the six cube map 2D image targets and the width and height parameters are not equal. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and height is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and height is less than 0 or greater than GL_MAX_ARRAY_TEXTURE_LAYERS. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if internalFormat is not one of the accepted resolution and format symbolic constants. 
GL_INVALID_VALUE is generated if width or height is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV, and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV, and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_RECTANGLE, and internalFormat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F. 
GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and internalFormat is not GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F. 
GL_INVALID_OPERATION is generated if internalFormat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F, and format is not GL_DEPTH_COMPONENT. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE and level is not 0. 

glTexImage2DMultisample
void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
GL_INVALID_OPERATION is generated if internalformat is a depth- or stencil-renderable format and samples is greater than the value of GL_MAX_DEPTH_TEXTURE_SAMPLES. 
GL_INVALID_OPERATION is generated if internalformat is a color-renderable format and samples is greater than the value of GL_MAX_COLOR_TEXTURE_SAMPLES. 
GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the value of GL_MAX_INTEGER_SAMPLES. 
GL_INVALID_VALUE is generated if either width or height negative or is greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if samples is greater than GL_MAX_SAMPLES. 

glTexImage3D
void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. Format constants other than GL_STENCIL_INDEX and GL_DEPTH_COMPONENT are accepted. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if internalFormat is not one of the accepted resolution and format symbolic constants. 
GL_INVALID_VALUE is generated if width, height, or depth is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format or internalFormat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

glTexImage3DMultisample
void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
GL_INVALID_OPERATION is generated if internalformat is a depth- or stencil-renderable format and samples is greater than the value of GL_MAX_DEPTH_TEXTURE_SAMPLES. 
GL_INVALID_OPERATION is generated if internalformat is a color-renderable format and samples is greater than the value of GL_MAX_COLOR_TEXTURE_SAMPLES. 
GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the value of GL_MAX_INTEGER_SAMPLES. 
GL_INVALID_VALUE is generated if either width or height negative or is greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if depth is negative or is greater than GL_MAX_ARRAY_TEXTURE_LAYERS. 
GL_INVALID_VALUE is generated if samples is greater than GL_MAX_SAMPLES. 

glTexParameterf
void glTexParameterf(GLenum target, GLenum pname, GLfloat param);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glTexParameteri
void glTexParameteri(GLenum target, GLenum pname, GLint param);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glTexParameterfv
void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glTexParameteriv
void glTexParameteriv(GLenum target, GLenum pname, const GLint * params);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glTexParameterIiv
void glTexParameterIiv(GLenum target, GLenum pname, const GLint * params);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glTexParameterIuiv
void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

glTexStorage1D
void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format. 
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_1D or GL_TEXTURE_2D. 
GL_INVALID_VALUE is generated if width or levels are less than 1. 
GL_INVALID_OPERATION is generated if levels is greater than log 2 width + 1 . 

glTexStorage2D
void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format. 
GL_INVALID_ENUM is generated if target is not one of the accepted target enumerants. 
GL_INVALID_VALUE is generated if width or levels are less than 1. 
GL_INVALID_OPERATION is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater than log 2 width + 1 . 
GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater than log 2 max width , height + 1 . 

glTexStorage2DMultisample
void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format. 
GL_INVALID_ENUM is generated if target is not one of the accepted target enumerants. 
GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if samples is greater than the value of GL_MAX_SAMPLES. 
GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE. 

glTexStorage3D
void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format. 
GL_INVALID_ENUM is generated if target is not one of the accepted target enumerants. 
GL_INVALID_VALUE is generated if width or levels are less than 1. 
GL_INVALID_OPERATION is generated if target is GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D and levels is greater than log 2 max width , height , depth + 1 . 
GL_INVALID_OPERATION is generated if target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXURE_CUBE_ARRAY, or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY and levels is greater than log 2 max width , height + 1 . 

glTexStorage3DMultisample
void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format. 
GL_INVALID_ENUM is generated if target is not one of the accepted target enumerants. 
GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if depth is less than 1 or greater than the value of GL_MAX_ARRAY_TEXTURE_LAYERS. 
GL_INVALID_VALUE is generated if samples is greater than the value of GL_MAX_SAMPLES. 
GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE. 

glTexSubImage1D
void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not one of the allowable values. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset &lt;
- b , or if xoffset + width &gt;
w - b , where w is the GL_TEXTURE_WIDTH, and b is the width of the GL_TEXTURE_BORDER of the texture image being modified. Note that w includes twice the border width. 
GL_INVALID_VALUE is generated if width is less than 0. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D operation. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

glTexSubImage2D
void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset &lt;
- b , xoffset + width &gt;
w - b , yoffset &lt;
- b , or yoffset + height &gt;
h - b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the border width of the texture image being modified. Note that w and h include twice the border width. 
GL_INVALID_VALUE is generated if width or height is less than 0. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D operation. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

glTexSubImage3D
void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if /target is not GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset &lt;
- b , xoffset + width &gt;
w - b , yoffset &lt;
- b , or yoffset + height &gt;
h - b , or zoffset &lt;
- b , or zoffset + depth &gt;
d - b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and b is the border width of the texture image being modified. Note that w, h, and d include twice the border width. 
GL_INVALID_VALUE is generated if width, height, or depth is less than 0. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D operation. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

glTextureView
void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
GL_INVALID_VALUE is generated if minlayer or minlevel are larger than the greatest layer or level of origtexture. 
GL_INVALID_OPERATION is generated if target is not compatible with the target of origtexture. 
GL_INVALID_OPERATION is generated if the dimensions of origtexture are greater than the maximum supported dimensions for target. 
GL_INVALID_OPERATION is generated if internalformat is not compatible with the internal format of origtexture. 
GL_INVALID_OPERATION is generated if texture has already been bound or otherwise given a target. 
GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for origtexture is not GL_TRUE. 
GL_INVALID_OPERATION is generated if origtexture is not the name of an existing texture object. 
GL_INVALID_VALUE is generaged if target is GL_TEXTURE_CUBE_MAP and numlayers is not 6, or if target is GL_TEXTURE_CUBE_MAP_ARRAY and numlayers is not an integer multiple of 6. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_2D_MULTISAMPLE and numlayers does not equal 1. 
GL_INVALID_VALUE is generated if texture zero or is not the name of a texture previously returned from a successful call to glGenTextures. 

glTransformFeedbackVaryings
void glTransformFeedbackVaryings(GLuintprogram, GLsizeicount, const char **varyings, GLenumbufferMode);
GL_INVALID_VALUE is generated if program is not the name of a program object. 
GL_INVALID_VALUE is generated if bufferMode is GL_SEPARATE_ATTRIBS and count is greater than the implementation-dependent limit GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS. 

glUniform1f
void glUniform1f(GLint location, GLfloat v0);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform2f
void glUniform2f(GLint location, GLfloat v0, GLfloat v1);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform3f
void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform4f
void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform1i
void glUniform1i(GLint location, GLint v0);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform2i
void glUniform2i(GLint location, GLint v0, GLint v1);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform3i
void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform4i
void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform1ui
void glUniform1ui(GLint location, GLuint v0);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform2ui
void glUniform2ui(GLint location, GLuint v0, GLuint v1);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform3ui
void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform4ui
void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform1fv
void glUniform1fv(GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform2fv
void glUniform2fv(GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform3fv
void glUniform3fv(GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform4fv
void glUniform4fv(GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform1iv
void glUniform1iv(GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform2iv
void glUniform2iv(GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform3iv
void glUniform3iv(GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform4iv
void glUniform4iv(GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform1uiv
void glUniform1uiv(GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform2uiv
void glUniform2uiv(GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform3uiv
void glUniform3uiv(GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniform4uiv
void glUniform4uiv(GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix2fv
void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix3fv
void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix4fv
void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix2x3fv
void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix3x2fv
void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix2x4fv
void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix4x2fv
void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix3x4fv
void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformMatrix4x3fv
void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

glUniformBlockBinding
void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
GL_INVALID_VALUE is generated if uniformBlockIndex is not an active uniform block index of program. 
GL_INVALID_VALUE is generated if uniformBlockBinding is greater than or equal to the value of GL_MAX_UNIFORM_BUFFER_BINDINGS. 
GL_INVALID_VALUE is generated if program is not the name of a program object generated by the GL. 

glUniformSubroutinesuiv
void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint *indices);
GL_INVALID_OPERATION is generated if no program object is current. 
GL_INVALID_VALUE is generated if count is not equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader stage shadertype of the current program. 
GL_INVALID_VALUE is generated if any value in indices is geater than or equal to the value of GL_ACTIVE_SUBROUTINES for the shader stage shadertype of the current program. 
GL_INVALID_ENUM is generated if shadertype is not one of the accepted values. 

glUseProgram
void glUseProgram(GLuint program);
GL_INVALID_VALUE is generated ifprogram is neither 0 nor a valuegenerated by OpenGL.
GL_INVALID_OPERATION is generated ifprogram is not a program object.
GL_INVALID_OPERATION is generated ifprogram could not be made part of currentstate.
GL_INVALID_OPERATION is generated iftransform feedback mode is active.

glUseProgramStages
void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
GL_INVALID_VALUE is generated if shaders contains set bits that are not recognized, and is not the reserved value GL_ALL_SHADER_BITS. 
GL_INVALID_OPERATION is generated if program refers to a program object that was not linked with its GL_PROGRAM_SEPARABLE status set. 
GL_INVALID_OPERATION is generated if program refers to a program object that has not been successfully linked. 
GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 

glValidateProgram
void glValidateProgram(GLuint program);
GL_INVALID_VALUE is generated ifprogram is not a value generated byOpenGL.
GL_INVALID_OPERATION is generated ifprogram is not a program object.

glValidateProgramPipeline
void glValidateProgramPipeline(GLuint pipeline);
GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 

glVertexAttrib1f
void glVertexAttrib1f(GLuint index, GLfloat v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib1s
void glVertexAttrib1s(GLuint index, GLshort v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib1d
void glVertexAttrib1d(GLuint index, GLdouble v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI1i
void glVertexAttribI1i(GLuint index, GLint v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI1ui
void glVertexAttribI1ui(GLuint index, GLuint v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib2f
void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib2s
void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib2d
void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI2i
void glVertexAttribI2i(GLuint index, GLint v0, GLint v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI2ui
void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib3f
void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib3s
void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib3d
void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI3i
void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI3ui
void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4f
void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4s
void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4d
void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4Nub
void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI4i
void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI4ui
void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribL1d
void glVertexAttribL1d(GLuint index, GLdouble v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribL2d
void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribL3d
void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribL4d
void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib1fv
void glVertexAttrib1fv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib1sv
void glVertexAttrib1sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib1dv
void glVertexAttrib1dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI1iv
void glVertexAttribI1iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI1uiv
void glVertexAttribI1uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib2fv
void glVertexAttrib2fv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib2sv
void glVertexAttrib2sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib2dv
void glVertexAttrib2dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI2iv
void glVertexAttribI2iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI2uiv
void glVertexAttribI2uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib3fv
void glVertexAttrib3fv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib3sv
void glVertexAttrib3sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib3dv
void glVertexAttrib3dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI3iv
void glVertexAttribI3iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI3uiv
void glVertexAttribI3uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4fv
void glVertexAttrib4fv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4sv
void glVertexAttrib4sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4dv
void glVertexAttrib4dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4iv
void glVertexAttrib4iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4bv
void glVertexAttrib4bv(GLuint index, const GLbyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4ubv
void glVertexAttrib4ubv(GLuint index, const GLubyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4usv
void glVertexAttrib4usv(GLuint index, const GLushort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4uiv
void glVertexAttrib4uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4Nbv
void glVertexAttrib4Nbv(GLuint index, const GLbyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4Nsv
void glVertexAttrib4Nsv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4Niv
void glVertexAttrib4Niv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4Nubv
void glVertexAttrib4Nubv(GLuint index, const GLubyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4Nusv
void glVertexAttrib4Nusv(GLuint index, const GLushort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttrib4Nuiv
void glVertexAttrib4Nuiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI4bv
void glVertexAttribI4bv(GLuint index, const GLbyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI4ubv
void glVertexAttribI4ubv(GLuint index, const GLubyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI4sv
void glVertexAttribI4sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI4usv
void glVertexAttribI4usv(GLuint index, const GLushort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI4iv
void glVertexAttribI4iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribI4uiv
void glVertexAttribI4uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribL1dv
void glVertexAttribL1dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribL2dv
void glVertexAttribL2dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribL3dv
void glVertexAttribL3dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribL4dv
void glVertexAttribL4dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribP1ui
void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribP2ui
void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribP3ui
void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribP4ui
void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

glVertexAttribBinding
void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVAILD_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

glVertexAttribDivisor
void glVertexAttribDivisor(GLuint index, GLuint divisor);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 

glVertexAttribFormat
void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
GL_INVAILD_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVALID_VALUE is generated if size is not one of the accepted values. 
GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET. 
GL_INVALID_ENUM is generated if type is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

glVertexAttribIFormat
void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
GL_INVAILD_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVALID_VALUE is generated if size is not one of the accepted values. 
GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET. 
GL_INVALID_ENUM is generated if type is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

glVertexAttribLFormat
void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
GL_INVAILD_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVALID_VALUE is generated if size is not one of the accepted values. 
GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET. 
GL_INVALID_ENUM is generated if type is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

glVertexAttribPointer
void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
GL_INVALID_ENUM is generated if type is not an accepted value.
GL_INVALID_VALUE is generated if stride is negative.
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.

glVertexAttribIPointer
void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
GL_INVALID_ENUM is generated if type is not an accepted value.
GL_INVALID_VALUE is generated if stride is negative.
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.

glVertexAttribLPointer
void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
GL_INVALID_ENUM is generated if type is not an accepted value.
GL_INVALID_VALUE is generated if stride is negative.
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.

glVertexBindingDivisor
void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);
GL_INVAILD_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

glViewport
void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
GL_INVALID_VALUE is generated if either width or height is negative. 

glViewportArrayv
void glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v);
GL_INVALID_VALUE is generated if first is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if first + count is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if either width or height is negative. 

glViewportIndexedf
void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if either width or height is negative. 

glViewportIndexedfv
void glViewportIndexedfv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if either width or height is negative. 

glWaitSync
void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
GL_INVALID_VALUE is generated if sync is not the name of a sync object. 
GL_INVALID_VALUE is generated if flags is not zero. 
GL_INVALID_VALUE is generated if timeout is not GL_TIMEOUT_IGNORED. 

