// Copyright (c) 2014, Tamas Csala

#ifndef OGLWRAP_ENUMS_CAPABILITY_H_
#define OGLWRAP_ENUMS_CAPABILITY_H_

#include "../config.h"

namespace oglwrap {

inline namespace enums {

enum class Capability : GLenum {
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_BLEND)
  Blend = GL_BLEND,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_CLIP_DISTANCE)
  ClipDistance = GL_CLIP_DISTANCE,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_COLOR_LOGIC_OP)
  ColorLogicOp = GL_COLOR_LOGIC_OP,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_CULL_FACE)
  CullFace = GL_CULL_FACE,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_DEBUG_OUTPUT)
  DebugOutput = GL_DEBUG_OUTPUT,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_DEBUG_OUTPUT_SYNCHRONOUS)
  DebugOutputSynchronous = GL_DEBUG_OUTPUT_SYNCHRONOUS,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_DEPTH_CLAMP)
  DepthClamp = GL_DEPTH_CLAMP,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_DEPTH_TEST)
  DepthTest = GL_DEPTH_TEST,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_DITHER)
  Dither = GL_DITHER,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_FRAMEBUFFER_SRGB)
  FramebufferSrgb = GL_FRAMEBUFFER_SRGB,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_LINE_SMOOTH)
  LineSmooth = GL_LINE_SMOOTH,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_MULTISAMPLE)
  Multisample = GL_MULTISAMPLE,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_POLYGON_OFFSET_FILL)
  PolygonOffsetFill = GL_POLYGON_OFFSET_FILL,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_POLYGON_OFFSET_LINE)
  PolygonOffsetLine = GL_POLYGON_OFFSET_LINE,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_POLYGON_OFFSET_POINT)
  PolgonOffsetPoint = GL_POLYGON_OFFSET_POINT,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_POLYGON_SMOOTH)
  PolygonSmooth = GL_POLYGON_SMOOTH,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_PRIMITIVE_RESTART)
  PrimitiveRestart = GL_PRIMITIVE_RESTART,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_PRIMITIVE_RESTART_FIXED_INDEX)
  PrimitiveRestartFixedIndex = GL_PRIMITIVE_RESTART_FIXED_INDEX,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_RASTERIZER_DISCARD)
  RasterizerDiscard = GL_RASTERIZER_DISCARD,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_SAMPLE_ALPHA_TO_COVERAGE)
  SampleAlphaToCoverage = GL_SAMPLE_ALPHA_TO_COVERAGE,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_SAMPLE_ALPHA_TO_ONE)
  SampleAlphaToOne = GL_SAMPLE_ALPHA_TO_ONE,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_SAMPLE_COVERAGE)
  SampleCoverage = GL_SAMPLE_COVERAGE,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_SAMPLE_SHADING)
  SampleShading = GL_SAMPLE_SHADING,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_SAMPLE_MASK)
  SampleMask = GL_SAMPLE_MASK,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_SCISSOR_TEST)
  ScissorTest = GL_SCISSOR_TEST,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_STENCIL_TEST)
  StencilTest = GL_STENCIL_TEST,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_TEXTURE_CUBE_MAP_SEAMLESS)
  TextureCubeMapSeamless = GL_TEXTURE_CUBE_MAP_SEAMLESS,
#endif
#if OGLWRAP_DEFINE_EVERYTHING || defined(GL_PROGRAM_POINT_SIZE)
  ProgramPointSize = GL_PROGRAM_POINT_SIZE,
#endif
};

} // enums

} // oglwrap

#endif
